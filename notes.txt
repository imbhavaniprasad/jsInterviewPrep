First-class functions refer to the concept that functions are treated like any other variable.

function decleration aka function statement :
function hi(){
    console.log("hii)
}
//Intersection Observer

The Intersection Observer is a JavaScript API that allows you to observe changes in the intersection (visibility) of a target element with respect to an ancestor element or the viewport. Itâ€™s often used to trigger animations or load content lazily (such as images) when an element comes into view, enhancing performance and user experience.
Use cases :

Lazy-loading images: Load images only when they are in or near the viewport.
Infinite scrolling: Load more content when the user scrolls to the bottom of the page.
Animations: Trigger animations when elements come into view (e.g., fade in).
Tracking visibility: Track when certain elements (ads, videos, etc.) become visible.

ex: const target = document.querySelector('.targetElement');

// Callback function that executes when the target intersects
const callback = (entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is in view!');
    } else {
      console.log('Element is out of view!');
    }
  });
};

// Create a new IntersectionObserver
const observer = new IntersectionObserver(callback, {
  root: null, // Default is the viewport
  rootMargin: '0px', // Margin around the root (viewport)
  threshold: 0.5 // Percentage of the target's visibility (0.5 = 50%)
});

// Start observing the target element
observer.observe(target);

---------------
Create setters & getters

class Person {
constructor(name) {
    this.name = name;
}
get name() {
    return this._name;
}
set name(value) {
    this._name = value;
}
}
var person = new Person("James");


person.name

person.name = "Jones"

person.name()

person._name = "Jones"

person.name

This statement will not produce an error. It calls the getter method of the name property, which returns the value of this._name. The result will be "James" after instantiation or "Jones" after reassignment.
person.name = "Jones"

This statement will not produce an error. It calls the setter method of the name property, which updates this._name to "Jones".
person.name()

This statement will produce an error because person.name is a property, not a function. Therefore, trying to call it as a function results in a TypeError (e.g., "person.name is not a function").
person._name = "Jones"

This statement will not produce an error. While directly modifying the "_name" property bypasses the setter method, it will still change the internal _name value to "Jones" without any issue.

-----*****Reason why we used _***-, if we hadn't used it & instead

class Person {
  constructor(name) {
    this.name = name;
  }
  get name() {
    return this.name;
  }
  set name(value) {
    this.name = value;
  }
}
This code would result in an infinite recursion, because the get and set methods would keep referring to themselves when you try to access this.name. Using this._name avoids this problem, as it creates a separate internal storage for the name.
